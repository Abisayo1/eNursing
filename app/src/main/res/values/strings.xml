<resources>
    <string name="app_name">cSimplify</string>
    <string name="open">Open</string>
    <string name="close">Close</string>
    <string name = "flow_beh"><b>Behavioural Objectives:</b>\n\nAt the end of the lesson, the students should be able to\n\n1. explain the concepts of flowcharts.\n\n2. identify the roles/functions of the basic flowchart symbols.\n\n3. represent a process in a flowchart.\n\n4. explain the advantages and disadvantages of using a flowchart.\n\n</string>
    <string name="definition"><b>Flowcharts</b>\n\nFlowchart is a graphical representation of an algorithm. Programmers often use it as a program-planning tool to solve a problem. It makes use of symbols which are connected among them to indicate the flow of information and processing.  <br /> <br /> The process of drawing a flowchart for an algorithm is known as “flowcharting”
    \n\nUsing a flowchart has a variety of benefits:\n\n

- It helps to clarify complex processes.\n\n
- It identifies steps that do not add value to the internal or external customer, including delays; needless storage and transportation; unnecessary work, duplication, and added expense; breakdowns in communication.\n\n
- It helps team members gain a shared understanding of the process and use this knowledge to collect data, identify problems, focus discussions, and identify resources.\n\n
- It serves as a basis for designing new processes.</string>
    <string name="gdg_description_terminal"><b>1. Terminal:</b> The oval symbol indicates Start, Stop and Halt in a program’s logic flow. A pause/halt is generally used in a program logic under some error conditions. Terminal is the first and last symbols in the flowchart.</string>
    <string name="input_output"><b>2. Input/Output:</b> A parallelogram denotes any function of input/output type. Program instructions that take input from input devices and display output on output devices are indicated with parallelogram in a flowchart. "</string>
    <string name="process"><b>3. Processing:</b> A box represents arithmetic instructions. All arithmetic processes such as adding, subtracting, multiplication and division are indicated by action or process symbol.</string>
    <string name="decision"><b>4. Decision:</b> Diamond symbol represents a decision point. Decision based operations such as yes/no question or true/false are indicated by diamond in flowchart. "</string>
    <string name="connectors"><b>5. Connectors:</b> Whenever flowchart becomes complex or it spreads over more than one page, it is useful to use connectors to avoid any confusions. It is represented by a circle. "</string>
    <string name="flowline"> <b> 6. Flow lines:</b> Flow lines indicate the exact sequence in which instructions are executed. Arrows represent the direction of flow of control and relationship among different symbols of flowchart. "</string>
    <string name="rules_flow">A flowchart is a graphical representation of an algorithm. it should follow some rules while creating a flowchart \n\n<b>Rule 1:</b> Flowchart opening statement must be ‘start’ keyword. \n\n<b>Rule 2:</b> Flowchart ending statement must be ‘end’ keyword. \n\n<b>Rule 3:</b> All symbols in the flowchart must be connected with an arrow line. \n\n<b>Rule 4:</b> The decision symbol in the flowchart cannot be associated with the arrow line.</string>
    <string name="advantages_flow"><b>1.</b> Flowcharts are a better way of communicating the logic of the system. \n\n<b>2.</b> Flowcharts act as a guide for blueprint during program designed. \n\n<b>3.</b> Flowcharts help in debugging process. \n\n<b>4.</b> With the help of flowcharts programs can be easily analyzed. \n\n<b>5.</b> It provides better documentation. \n\n<b>6.</b> Flowcharts serve as a good proper documentation. \n\n<b>6.</b> Easy to trace errors in the software. \n\n<b>8.</b> Easy to understand. \n\n<b>9.</b> The flowchart can be reused for inconvenience in the future. \n\n<b>10.</b> It helps to provide correct logic.</string>
    <string name="disadvantages_flow"><b>1.</b> It is difficult to draw flowcharts for large and complex programs. \n\n<b>2.</b> There is no standard to determine the amount of detail. \n\n<b>3.</b> Difficult to reproduce the flowcharts. \n\n<b>4.</b> It is very difficult to modify the Flowchart. \n\n<b>5.</b> Making a flowchart is costly. \n\n<b>6.</b> Some developer thinks that it is waste of time. \n\n<b>7.</b> It makes software processes low. \n\n<b>8.</b> If changes are done in software, then the flowchart must be redrawn\n\n</string>
    <string name="algo_beh"><b>Behavioural Objectives:</b>\n\nAt the end of the lesson, students should be able to:\n\n1. explain the concept of algorithm.\n\n2. describe at least 3 types of algorithm.\n\n3. compare the types of algorithms in terms of their use.\n\n4. describe the importance of algorithms to solving complex problems; and\n\n5. describe the steps in creating/writing an algorithm for a given problem\n\n</string>
    <string name="algo_def"><b>Algorithms</b>\n\nThe word Algorithm means ”A  set of rules to be followed in calculations or other problem-solving operations” Or ”A procedure for solving a mathematical problem in a finite number of steps that frequently by recursive operations “.   \n\nTherefore Algorithm refers to a sequence of finite steps to solve a particular problem.</string>
    <string name="types_algo">There are several types of algorithms available. \n\nSome important algorithms are:  \n\n<b>1. Brute Force Algorithm:</b> It is the simplest approach for a problem. A brute force algorithm is the first approach that comes to finding when we see a problem.\n\n<b>2. Recursive Algorithm:</b> A recursive algorithm is based on recursion. In this case, a problem is broken into several sub-parts and called the same function again and again.
    \n\n<b>3. Backtracking Algorithm:</b> The backtracking algorithm basically builds the solution by searching among all possible solutions. Using this algorithm, we keep on building the solution following criteria. Whenever a solution fails we trace back to the failure point and build on the next solution and continue this process till we find the solution or all possible solutions are looked after.\n\n<b>4. Searching Algorithm:</b> Searching algorithms are the ones that are used for searching elements or groups of elements from a particular data structure. They can be of different types based on their approach or the data structure in which the element should be found.\n\n<b>5. Sorting Algorithm:</b> Sorting is arranging a group of data in a particular manner according to the requirement. The algorithms which help in performing this function are called sorting algorithms. Generally sorting algorithms are used to sort groups of data in an increasing or decreasing manner.\n\n<b>7. Divide and Conquer Algorithm:</b> This algorithm breaks a problem into sub-problems, solves a single sub-problem and merges the solutions together to get the final solution. It consists of the following three steps:  \n- Divide \n- Solve \n- Combine</string>
    <string name="characteristic_algo">Algorithms generally have the following characteristics: \n\n<b>Input:</b> An algorithm requires some input values. An algorithm can be given a value other than 0 as input.
        \n\n<b>Output:</b> At the end of an algorithm, you will have one or more outcomes.
        \n\n<b>Unambiguity:</b> A perfect algorithm is defined as unambiguous, which means that its instructions should be clear and straightforward.
        \n\n<b>Finiteness:</b> An algorithm must be finite. Finiteness in this context means that the algorithm should have a limited number of instructions, i.e., the instructions should be countable.
        \n\n<b>Effectiveness:</b> Because each instruction in an algorithm affects the overall process, it should be adequate.
        \n\n<b>Language independence:</b> An algorithm must be language-independent, which means that its instructions can be implemented in any language and produce the same results</string>
    <string name="algo_func">You require algorithms for the following reasons:  \n\n<b>Scalability</b> It aids in your understanding of scalability. When you have a sizable real-world problem, you must break it down into small steps to analyze it quickly.  \n\n<b>Performance</b> The real world is challenging to break down into smaller steps. If a problem can be easily divided into smaller steps, it indicates that the problem is feasible.</string>
    <string name="algo_how_write">There are no well-defined standards for writing algorithms. It is, however, a problem that is resource-dependent. \n\nAlgorithms are never written with a specific programming language in mind. As you all know, basic code constructs such as loops like do, for, while, all programming languages share flow control such as if-else, and so on. An algorithm can be written using these common constructs. \n\nAlgorithms are typically written in a step-by-step fashion, but this is not always the case. Algorithm writing is a process that occurs after the problem domain has been well-defined. That is, you must be aware of the problem domain for which you are developing a solution.</string>
    <string name="examples_flow">The following are examples of flowcharts: \n\n1. Draw a flowchart to input two numbers from the user and display the largest of two numbers:</string>
    <string name="example_algo">The following are examples of an algorithm:\n\n<b>Problem 1:</b> Create an algorithm that multiplies two numbers and  displays the output.\n\nStep 1 − Start\n\n

Step 2 − declare three integers x, y &amp; z\n\n

Step 3 − define values of x &amp; y\n\n

Step 4 − multiply values of x &amp; y\n\n

Step 5 − store result of step 4 to z\n\n

Step 6 − print z\n\n

        Step 7 − Stop\n\n<b>Problem 2:</b> Write an algorithm to add two numbers together:\n\nStep 1 − Start\n\n

Step 2 − Input two numbers say A and B\n\n

Step 3 − SUM = A+B\n\n

Step 4 − Display SUM\n\n

Step 5 − Stop\n\n<b>Problem 3:</b> Write an algorithm to find the area and perimeter of a square:\n\nL: Side length of square\n AREA: Area of square\nPERIMETER: Perimeter of square\n\nStep 1 − Start\n\n

Step 2 − Input side length of square, say L\n\n

Step 3 − AREA = L * L\n\n

Step 4 − PERIMETER = 4 * L\n\n

Step 5 − Display AREA, PERIMETER\n\n
        Step 6 − Stop</string>
    <string name="examples_flow2">2. Find the largest among three different numbers entered by the user.</string>
    <string name="examples_flow3">3. Find all the roots of a quadratic equation ax2+bx+c=0</string>
    <string name="examples_flow4">4. Determine and Output Whether Number N is Even or Odd.</string>
    <!-- TODO: Remove or change this placeholder text -->
    <string name="hello_blank_fragment">Hello blank fragment</string>
</resources>